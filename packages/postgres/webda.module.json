{
  "beans": {},
  "deployers": {},
  "moddas": {
    "Webda/PostgresStore": "lib/postgresstore:default"
  },
  "models": {
    "graph": {},
    "tree": {},
    "plurals": {},
    "list": {},
    "reflections": {}
  },
  "schemas": {
    "Webda/BinaryFile": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "description": "Will be computed by the service\n\nhash of the content"
        },
        "challenge": {
          "type": "string",
          "description": "Will be computed by the service\n\nhash of the content prefixed by 'WEBDA'"
        },
        "size": {
          "type": "number",
          "description": "Size of the binary"
        },
        "name": {
          "type": "string",
          "description": "Current name"
        },
        "mimetype": {
          "type": "string",
          "description": "Mimetype of the binary"
        },
        "metadata": {
          "description": "Metadatas stored along with the binary"
        },
        "originalname": {
          "type": "string",
          "description": "Original name"
        }
      },
      "required": [
        "mimetype",
        "name",
        "size"
      ],
      "description": "Represent a file to store",
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BinaryFile"
    },
    "Webda/PostgresStore": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type of the service"
        },
        "url": {
          "type": "string",
          "description": "URL on which to serve the content"
        },
        "model": {
          "type": "string",
          "description": "Webda model to use within the Store",
          "default": "Webda/CoreModel"
        },
        "additionalModels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Additional models\n\nAllow this store to manage other models",
          "default": []
        },
        "asyncDelete": {
          "type": "boolean",
          "description": "async delete"
        },
        "expose": {
          "$ref": "#/definitions/StoreExposeParameters",
          "description": "Expose the service to an urls",
          "deprecated": "will probably be removed in 4.0 in favor of Expose annotation"
        },
        "strict": {
          "type": "boolean",
          "description": "Allow to load object that does not have the type data\n\nIf set to true, then the Store will only managed the defined _model and no model extending this one",
          "default": false
        },
        "defaultModel": {
          "type": "boolean",
          "description": "When __type model not found, use the model If strict is setup this parameter is not used",
          "default": true
        },
        "forceModel": {
          "type": "boolean",
          "description": "If set, Store will ignore the __type",
          "default": false
        },
        "slowQueryThreshold": {
          "type": "number",
          "description": "Slow query threshold",
          "default": 30000
        },
        "modelAliases": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Model Aliases to allow easier rename of Model"
        },
        "noCache": {
          "type": "boolean",
          "description": "Disable default memory cache"
        },
        "table": {
          "type": "string"
        },
        "database": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name"
          ]
        },
        "usePool": {
          "type": "boolean",
          "default": false
        },
        "postgresqlServer": {
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "user": {
                  "type": "string"
                },
                "database": {
                  "type": "string"
                },
                "password": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {}
                  ]
                },
                "port": {
                  "type": "number"
                },
                "host": {
                  "type": "string"
                },
                "connectionString": {
                  "type": "string"
                },
                "keepAlive": {
                  "type": "boolean"
                },
                "stream": {
                  "type": "object",
                  "properties": {
                    "writable": {
                      "type": "boolean",
                      "description": "Is `true` if it is safe to call `writable.write()`, which means the stream has not been destroyed, errored or ended."
                    },
                    "writableEnded": {
                      "type": "boolean",
                      "description": "Is `true` after `writable.end()` has been called. This property does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead."
                    },
                    "writableFinished": {
                      "type": "boolean",
                      "description": "Is set to `true` immediately before the `'finish'` event is emitted."
                    },
                    "writableHighWaterMark": {
                      "type": "number",
                      "description": "Return the value of `highWaterMark` passed when creating this `Writable`."
                    },
                    "writableLength": {
                      "type": "number",
                      "description": "This property contains the number of bytes (or objects) in the queue ready to be written. The value provides introspection data regarding the status of the `highWaterMark`."
                    },
                    "writableObjectMode": {
                      "type": "boolean",
                      "description": "Getter for the property `objectMode` of a given `Writable` stream."
                    },
                    "writableCorked": {
                      "type": "number",
                      "description": "Number of times `writable.uncork()` needs to be called in order to fully uncork the stream."
                    },
                    "destroyed": {
                      "type": "boolean",
                      "description": "Is `true` after `readable.destroy()` has been called."
                    },
                    "closed": {
                      "type": "boolean",
                      "description": "Is true after 'close' has been emitted."
                    },
                    "errored": {
                      "anyOf": [
                        {
                          "type": "object",
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "message": {
                              "type": "string"
                            },
                            "stack": {
                              "type": "string"
                            }
                          },
                          "required": [
                            "name",
                            "message"
                          ]
                        },
                        {
                          "type": "null"
                        }
                      ],
                      "description": "Returns error if the stream has been destroyed with an error."
                    },
                    "writableNeedDrain": {
                      "type": "boolean",
                      "description": "Is `true` if the stream's buffer has been full and stream will emit 'drain'."
                    },
                    "readable": {
                      "type": "boolean",
                      "description": "Is `true` if it is safe to call `readable.read()`, which means the stream has not been destroyed or emitted `'error'` or `'end'`."
                    },
                    "readableAborted": {
                      "type": "boolean",
                      "description": "Returns whether the stream was destroyed or errored before emitting `'end'`."
                    },
                    "readableDidRead": {
                      "type": "boolean",
                      "description": "Returns whether `'data'` has been emitted."
                    },
                    "readableEncoding": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/global.BufferEncoding"
                        },
                        {
                          "type": "null"
                        }
                      ],
                      "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                    },
                    "readableEnded": {
                      "type": "boolean",
                      "description": "Becomes `true` when `'end'` event is emitted."
                    },
                    "readableFlowing": {
                      "type": [
                        "boolean",
                        "null"
                      ],
                      "description": "This property reflects the current state of a `Readable` stream as described in the `Three states` section."
                    },
                    "readableHighWaterMark": {
                      "type": "number",
                      "description": "Returns the value of `highWaterMark` passed when creating this `Readable`."
                    },
                    "readableLength": {
                      "type": "number",
                      "description": "This property contains the number of bytes (or objects) in the queue ready to be read. The value provides introspection data regarding the status of the `highWaterMark`."
                    },
                    "readableObjectMode": {
                      "type": "boolean",
                      "description": "Getter for the property `objectMode` of a given `Readable` stream."
                    },
                    "allowHalfOpen": {
                      "type": "boolean",
                      "description": "If `false` then the stream will automatically end the writable side when the readable side ends. Set initially by the `allowHalfOpen` constructor option, which defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is emitted."
                    }
                  },
                  "required": [
                    "allowHalfOpen",
                    "closed",
                    "destroyed",
                    "errored",
                    "readable",
                    "readableAborted",
                    "readableDidRead",
                    "readableEncoding",
                    "readableEnded",
                    "readableFlowing",
                    "readableHighWaterMark",
                    "readableLength",
                    "readableObjectMode",
                    "writable",
                    "writableCorked",
                    "writableEnded",
                    "writableFinished",
                    "writableHighWaterMark",
                    "writableLength",
                    "writableNeedDrain",
                    "writableObjectMode"
                  ],
                  "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "statement_timeout": {
                  "anyOf": [
                    {
                      "type": "boolean",
                      "const": false
                    },
                    {
                      "type": "number"
                    }
                  ]
                },
                "parseInputDatesAsUTC": {
                  "type": "boolean"
                },
                "ssl": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "object",
                      "properties": {
                        "secureContext": {
                          "type": "object",
                          "properties": {
                            "context": {}
                          },
                          "required": [
                            "context"
                          ],
                          "description": "An optional TLS context object from tls.createSecureContext()"
                        },
                        "enableTrace": {
                          "type": "boolean",
                          "description": "When enabled, TLS packet trace information is written to `stderr`. This can be used to debug TLS connection problems.",
                          "default": false
                        },
                        "requestCert": {
                          "type": "boolean",
                          "description": "If true the server will request a certificate from clients that connect and attempt to verify that certificate. Defaults to false."
                        },
                        "ALPNProtocols": {
                          "anyOf": [
                            {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                  },
                                  "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                  },
                                  "byteLength": {
                                    "type": "number"
                                  },
                                  "byteOffset": {
                                    "type": "number"
                                  },
                                  "length": {
                                    "type": "number"
                                  }
                                },
                                "required": [
                                  "BYTES_PER_ELEMENT",
                                  "buffer",
                                  "byteLength",
                                  "byteOffset",
                                  "length"
                                ],
                                "additionalProperties": {
                                  "type": "number"
                                }
                              }
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ],
                              "additionalProperties": {
                                "type": "number"
                              }
                            }
                          ],
                          "description": "An array of strings or a Buffer naming possible ALPN protocols. (Protocols should be ordered by their priority.)"
                        },
                        "SNICallback": {
                          "description": "SNICallback(servername, cb) <Function> A function that will be called if the client supports SNI TLS extension. Two arguments will be passed when called: servername and cb. SNICallback should invoke cb(null, ctx), where ctx is a SecureContext instance. (tls.createSecureContext(...) can be used to get a proper SecureContext.) If SNICallback wasn't provided the default callback with high-level API will be used (see below)."
                        },
                        "rejectUnauthorized": {
                          "type": "boolean",
                          "description": "If true the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if requestCert is true.",
                          "default": true
                        },
                        "ca": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option."
                        },
                        "cert": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private key, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see ca). When providing multiple cert chains, they do not have to be in the same order as their private keys in key. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail."
                        },
                        "sigalgs": {
                          "type": "string",
                          "description": "Colon-separated list of supported signature algorithms. The list can contain digest algorithms (SHA256, MD5 etc.), public key algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g 'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512)."
                        },
                        "ciphers": {
                          "type": "string",
                          "description": "Cipher suite specification, replacing the default. For more information, see modifying the default cipher suite. Permitted ciphers can be obtained via tls.getCiphers(). Cipher names must be uppercased in order for OpenSSL to accept them."
                        },
                        "clientCertEngine": {
                          "type": "string",
                          "description": "Name of an OpenSSL engine which can provide the client certificate."
                        },
                        "crl": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                        },
                        "dhparam": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            }
                          ],
                          "description": "Diffie Hellman parameters, required for Perfect Forward Secrecy. Use openssl dhparam to create the parameters. The key length must be greater than or equal to 1024 bits or else an error will be thrown. Although 1024 bits is permissible, use 2048 bits or larger for stronger security. If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available."
                        },
                        "ecdhCurve": {
                          "type": "string",
                          "description": "A string describing a named curve or a colon separated list of curve NIDs or names, for example P-521:P-384:P-256, to use for ECDH key agreement. Set to auto to select the curve automatically. Use crypto.getCurves() to obtain a list of available curve names. On recent releases, openssl ecparam -list_curves will also display the name and description of each available elliptic curve. Default: tls.DEFAULT_ECDH_CURVE."
                        },
                        "honorCipherOrder": {
                          "type": "boolean",
                          "description": "Attempt to use the server's cipher suite preferences instead of the client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be set in secureOptions"
                        },
                        "key": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "pem": {
                                        "anyOf": [
                                          {
                                            "type": "string"
                                          },
                                          {
                                            "type": "object",
                                            "properties": {
                                              "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                              },
                                              "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                              },
                                              "byteLength": {
                                                "type": "number"
                                              },
                                              "byteOffset": {
                                                "type": "number"
                                              },
                                              "length": {
                                                "type": "number"
                                              }
                                            },
                                            "required": [
                                              "BYTES_PER_ELEMENT",
                                              "buffer",
                                              "byteLength",
                                              "byteOffset",
                                              "length"
                                            ]
                                          }
                                        ],
                                        "description": "Private keys in PEM format."
                                      },
                                      "passphrase": {
                                        "type": "string",
                                        "description": "Optional passphrase."
                                      }
                                    },
                                    "required": [
                                      "pem"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with options.passphrase. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form {pem: <string|buffer>[, passphrase: <string>]}. The object form can only occur in an array. object.passphrase is optional. Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase if it is not."
                        },
                        "privateKeyEngine": {
                          "type": "string",
                          "description": "Name of an OpenSSL engine to get private key from. Should be used together with privateKeyIdentifier."
                        },
                        "privateKeyIdentifier": {
                          "type": "string",
                          "description": "Identifier of a private key managed by an OpenSSL engine. Should be used together with privateKeyEngine. Should not be set together with key, because both options define a private key in different ways."
                        },
                        "maxVersion": {
                          "$ref": "#/definitions/SecureVersion",
                          "description": "Optionally set the maximum TLS version to allow. One of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the `secureProtocol` option, use one or the other.\n**Default:** `'TLSv1.3'`, unless changed using CLI options. Using `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used."
                        },
                        "minVersion": {
                          "$ref": "#/definitions/SecureVersion",
                          "description": "Optionally set the minimum TLS version to allow. One of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the `secureProtocol` option, use one or the other.  It is not recommended to use less than TLSv1.2, but it may be required for interoperability.\n**Default:** `'TLSv1.2'`, unless changed using CLI options. Using `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used."
                        },
                        "passphrase": {
                          "type": "string",
                          "description": "Shared passphrase used for a single private key and/or a PFX."
                        },
                        "pfx": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "buf": {
                                        "anyOf": [
                                          {
                                            "type": "string"
                                          },
                                          {
                                            "type": "object",
                                            "properties": {
                                              "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                              },
                                              "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                              },
                                              "byteLength": {
                                                "type": "number"
                                              },
                                              "byteOffset": {
                                                "type": "number"
                                              },
                                              "length": {
                                                "type": "number"
                                              }
                                            },
                                            "required": [
                                              "BYTES_PER_ELEMENT",
                                              "buffer",
                                              "byteLength",
                                              "byteOffset",
                                              "length"
                                            ]
                                          }
                                        ],
                                        "description": "PFX or PKCS12 encoded private key and certificate chain."
                                      },
                                      "passphrase": {
                                        "type": "string",
                                        "description": "Optional passphrase."
                                      }
                                    },
                                    "required": [
                                      "buf"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an alternative to providing key and cert individually. PFX is usually encrypted, if it is, passphrase will be used to decrypt it. Multiple PFX can be provided either as an array of unencrypted PFX buffers, or an array of objects in the form {buf: <string|buffer>[, passphrase: <string>]}. The object form can only occur in an array. object.passphrase is optional. Encrypted PFX will be decrypted with object.passphrase if provided, or options.passphrase if it is not."
                        },
                        "secureOptions": {
                          "type": "number",
                          "description": "Optionally affect the OpenSSL protocol behavior, which is not usually necessary. This should be used carefully if at all! Value is a numeric bitmask of the SSL_OP_* options from OpenSSL Options"
                        },
                        "secureProtocol": {
                          "type": "string",
                          "description": "Legacy mechanism to select the TLS protocol version to use, it does not support independent control of the minimum and maximum version, and does not support limiting the protocol to TLSv1.3. Use minVersion and maxVersion instead. The possible values are listed as SSL_METHODS, use the function names as strings. For example, use 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow any TLS protocol version up to TLSv1.3. It is not recommended to use TLS versions less than 1.2, but it may be required for interoperability. Default: none, see minVersion."
                        },
                        "sessionIdContext": {
                          "type": "string",
                          "description": "Opaque identifier used by servers to ensure session state is not shared between applications. Unused by clients."
                        },
                        "ticketKeys": {
                          "type": "object",
                          "properties": {
                            "BYTES_PER_ELEMENT": {
                              "type": "number"
                            },
                            "buffer": {
                              "$ref": "#/definitions/ArrayBufferLike"
                            },
                            "byteLength": {
                              "type": "number"
                            },
                            "byteOffset": {
                              "type": "number"
                            },
                            "length": {
                              "type": "number"
                            }
                          },
                          "required": [
                            "BYTES_PER_ELEMENT",
                            "buffer",
                            "byteLength",
                            "byteOffset",
                            "length"
                          ],
                          "description": "48-bytes of cryptographically strong pseudo-random data. See Session Resumption for more information."
                        },
                        "sessionTimeout": {
                          "type": "number",
                          "description": "The number of seconds after which a TLS session created by the server will no longer be resumable. See Session Resumption for more information. Default: 300."
                        },
                        "host": {
                          "type": "string"
                        },
                        "port": {
                          "type": "number"
                        },
                        "path": {
                          "type": "string"
                        },
                        "socket": {
                          "type": "object",
                          "properties": {
                            "writable": {
                              "type": "boolean",
                              "description": "Is `true` if it is safe to call `writable.write()`, which means the stream has not been destroyed, errored or ended."
                            },
                            "writableEnded": {
                              "type": "boolean",
                              "description": "Is `true` after `writable.end()` has been called. This property does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead."
                            },
                            "writableFinished": {
                              "type": "boolean",
                              "description": "Is set to `true` immediately before the `'finish'` event is emitted."
                            },
                            "writableHighWaterMark": {
                              "type": "number",
                              "description": "Return the value of `highWaterMark` passed when creating this `Writable`."
                            },
                            "writableLength": {
                              "type": "number",
                              "description": "This property contains the number of bytes (or objects) in the queue ready to be written. The value provides introspection data regarding the status of the `highWaterMark`."
                            },
                            "writableObjectMode": {
                              "type": "boolean",
                              "description": "Getter for the property `objectMode` of a given `Writable` stream."
                            },
                            "writableCorked": {
                              "type": "number",
                              "description": "Number of times `writable.uncork()` needs to be called in order to fully uncork the stream."
                            },
                            "destroyed": {
                              "type": "boolean",
                              "description": "Is `true` after `readable.destroy()` has been called."
                            },
                            "closed": {
                              "type": "boolean",
                              "description": "Is true after 'close' has been emitted."
                            },
                            "errored": {
                              "anyOf": [
                                {
                                  "type": "object",
                                  "properties": {
                                    "name": {
                                      "type": "string"
                                    },
                                    "message": {
                                      "type": "string"
                                    },
                                    "stack": {
                                      "type": "string"
                                    }
                                  },
                                  "required": [
                                    "name",
                                    "message"
                                  ]
                                },
                                {
                                  "type": "null"
                                }
                              ],
                              "description": "Returns error if the stream has been destroyed with an error."
                            },
                            "writableNeedDrain": {
                              "type": "boolean",
                              "description": "Is `true` if the stream's buffer has been full and stream will emit 'drain'."
                            },
                            "readable": {
                              "type": "boolean",
                              "description": "Is `true` if it is safe to call `readable.read()`, which means the stream has not been destroyed or emitted `'error'` or `'end'`."
                            },
                            "readableAborted": {
                              "type": "boolean",
                              "description": "Returns whether the stream was destroyed or errored before emitting `'end'`."
                            },
                            "readableDidRead": {
                              "type": "boolean",
                              "description": "Returns whether `'data'` has been emitted."
                            },
                            "readableEncoding": {
                              "anyOf": [
                                {
                                  "$ref": "#/definitions/global.BufferEncoding"
                                },
                                {
                                  "type": "null"
                                }
                              ],
                              "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                            },
                            "readableEnded": {
                              "type": "boolean",
                              "description": "Becomes `true` when `'end'` event is emitted."
                            },
                            "readableFlowing": {
                              "type": [
                                "boolean",
                                "null"
                              ],
                              "description": "This property reflects the current state of a `Readable` stream as described in the `Three states` section."
                            },
                            "readableHighWaterMark": {
                              "type": "number",
                              "description": "Returns the value of `highWaterMark` passed when creating this `Readable`."
                            },
                            "readableLength": {
                              "type": "number",
                              "description": "This property contains the number of bytes (or objects) in the queue ready to be read. The value provides introspection data regarding the status of the `highWaterMark`."
                            },
                            "readableObjectMode": {
                              "type": "boolean",
                              "description": "Getter for the property `objectMode` of a given `Readable` stream."
                            },
                            "allowHalfOpen": {
                              "type": "boolean",
                              "description": "If `false` then the stream will automatically end the writable side when the readable side ends. Set initially by the `allowHalfOpen` constructor option, which defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is emitted."
                            }
                          },
                          "required": [
                            "allowHalfOpen",
                            "closed",
                            "destroyed",
                            "errored",
                            "readable",
                            "readableAborted",
                            "readableDidRead",
                            "readableEncoding",
                            "readableEnded",
                            "readableFlowing",
                            "readableHighWaterMark",
                            "readableLength",
                            "readableObjectMode",
                            "writable",
                            "writableCorked",
                            "writableEnded",
                            "writableFinished",
                            "writableHighWaterMark",
                            "writableLength",
                            "writableNeedDrain",
                            "writableObjectMode"
                          ],
                          "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                        },
                        "checkServerIdentity": {
                          "$comment": "(hostname: string, cert: PeerCertificate) ->  Error | undefined"
                        },
                        "servername": {
                          "type": "string"
                        },
                        "session": {
                          "type": "object",
                          "properties": {
                            "BYTES_PER_ELEMENT": {
                              "type": "number"
                            },
                            "buffer": {
                              "$ref": "#/definitions/ArrayBufferLike"
                            },
                            "byteLength": {
                              "type": "number"
                            },
                            "byteOffset": {
                              "type": "number"
                            },
                            "length": {
                              "type": "number"
                            }
                          },
                          "required": [
                            "BYTES_PER_ELEMENT",
                            "buffer",
                            "byteLength",
                            "byteOffset",
                            "length"
                          ]
                        },
                        "minDHSize": {
                          "type": "number"
                        },
                        "lookup": {
                          "$ref": "#/definitions/LookupFunction"
                        },
                        "timeout": {
                          "type": "number"
                        }
                      }
                    }
                  ]
                },
                "query_timeout": {
                  "type": "number"
                },
                "keepAliveInitialDelayMillis": {
                  "type": "number"
                },
                "idle_in_transaction_session_timeout": {
                  "type": "number"
                },
                "application_name": {
                  "type": "string"
                },
                "connectionTimeoutMillis": {
                  "type": "number"
                },
                "types": {
                  "type": "object",
                  "properties": {
                    "getTypeParser": {}
                  },
                  "required": [
                    "getTypeParser"
                  ]
                }
              }
            },
            {
              "type": "object",
              "properties": {
                "user": {
                  "type": "string"
                },
                "database": {
                  "type": "string"
                },
                "password": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {}
                  ]
                },
                "port": {
                  "type": "number"
                },
                "host": {
                  "type": "string"
                },
                "connectionString": {
                  "type": "string"
                },
                "keepAlive": {
                  "type": "boolean"
                },
                "stream": {
                  "type": "object",
                  "properties": {
                    "writable": {
                      "type": "boolean",
                      "description": "Is `true` if it is safe to call `writable.write()`, which means the stream has not been destroyed, errored or ended."
                    },
                    "writableEnded": {
                      "type": "boolean",
                      "description": "Is `true` after `writable.end()` has been called. This property does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead."
                    },
                    "writableFinished": {
                      "type": "boolean",
                      "description": "Is set to `true` immediately before the `'finish'` event is emitted."
                    },
                    "writableHighWaterMark": {
                      "type": "number",
                      "description": "Return the value of `highWaterMark` passed when creating this `Writable`."
                    },
                    "writableLength": {
                      "type": "number",
                      "description": "This property contains the number of bytes (or objects) in the queue ready to be written. The value provides introspection data regarding the status of the `highWaterMark`."
                    },
                    "writableObjectMode": {
                      "type": "boolean",
                      "description": "Getter for the property `objectMode` of a given `Writable` stream."
                    },
                    "writableCorked": {
                      "type": "number",
                      "description": "Number of times `writable.uncork()` needs to be called in order to fully uncork the stream."
                    },
                    "destroyed": {
                      "type": "boolean",
                      "description": "Is `true` after `readable.destroy()` has been called."
                    },
                    "closed": {
                      "type": "boolean",
                      "description": "Is true after 'close' has been emitted."
                    },
                    "errored": {
                      "anyOf": [
                        {
                          "type": "object",
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "message": {
                              "type": "string"
                            },
                            "stack": {
                              "type": "string"
                            }
                          },
                          "required": [
                            "name",
                            "message"
                          ]
                        },
                        {
                          "type": "null"
                        }
                      ],
                      "description": "Returns error if the stream has been destroyed with an error."
                    },
                    "writableNeedDrain": {
                      "type": "boolean",
                      "description": "Is `true` if the stream's buffer has been full and stream will emit 'drain'."
                    },
                    "readable": {
                      "type": "boolean",
                      "description": "Is `true` if it is safe to call `readable.read()`, which means the stream has not been destroyed or emitted `'error'` or `'end'`."
                    },
                    "readableAborted": {
                      "type": "boolean",
                      "description": "Returns whether the stream was destroyed or errored before emitting `'end'`."
                    },
                    "readableDidRead": {
                      "type": "boolean",
                      "description": "Returns whether `'data'` has been emitted."
                    },
                    "readableEncoding": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/global.BufferEncoding"
                        },
                        {
                          "type": "null"
                        }
                      ],
                      "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                    },
                    "readableEnded": {
                      "type": "boolean",
                      "description": "Becomes `true` when `'end'` event is emitted."
                    },
                    "readableFlowing": {
                      "type": [
                        "boolean",
                        "null"
                      ],
                      "description": "This property reflects the current state of a `Readable` stream as described in the `Three states` section."
                    },
                    "readableHighWaterMark": {
                      "type": "number",
                      "description": "Returns the value of `highWaterMark` passed when creating this `Readable`."
                    },
                    "readableLength": {
                      "type": "number",
                      "description": "This property contains the number of bytes (or objects) in the queue ready to be read. The value provides introspection data regarding the status of the `highWaterMark`."
                    },
                    "readableObjectMode": {
                      "type": "boolean",
                      "description": "Getter for the property `objectMode` of a given `Readable` stream."
                    },
                    "allowHalfOpen": {
                      "type": "boolean",
                      "description": "If `false` then the stream will automatically end the writable side when the readable side ends. Set initially by the `allowHalfOpen` constructor option, which defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is emitted."
                    }
                  },
                  "required": [
                    "allowHalfOpen",
                    "closed",
                    "destroyed",
                    "errored",
                    "readable",
                    "readableAborted",
                    "readableDidRead",
                    "readableEncoding",
                    "readableEnded",
                    "readableFlowing",
                    "readableHighWaterMark",
                    "readableLength",
                    "readableObjectMode",
                    "writable",
                    "writableCorked",
                    "writableEnded",
                    "writableFinished",
                    "writableHighWaterMark",
                    "writableLength",
                    "writableNeedDrain",
                    "writableObjectMode"
                  ],
                  "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "statement_timeout": {
                  "anyOf": [
                    {
                      "type": "boolean",
                      "const": false
                    },
                    {
                      "type": "number"
                    }
                  ]
                },
                "parseInputDatesAsUTC": {
                  "type": "boolean"
                },
                "ssl": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "object",
                      "properties": {
                        "secureContext": {
                          "type": "object",
                          "properties": {
                            "context": {}
                          },
                          "required": [
                            "context"
                          ],
                          "description": "An optional TLS context object from tls.createSecureContext()"
                        },
                        "enableTrace": {
                          "type": "boolean",
                          "description": "When enabled, TLS packet trace information is written to `stderr`. This can be used to debug TLS connection problems.",
                          "default": false
                        },
                        "requestCert": {
                          "type": "boolean",
                          "description": "If true the server will request a certificate from clients that connect and attempt to verify that certificate. Defaults to false."
                        },
                        "ALPNProtocols": {
                          "anyOf": [
                            {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                  },
                                  "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                  },
                                  "byteLength": {
                                    "type": "number"
                                  },
                                  "byteOffset": {
                                    "type": "number"
                                  },
                                  "length": {
                                    "type": "number"
                                  }
                                },
                                "required": [
                                  "BYTES_PER_ELEMENT",
                                  "buffer",
                                  "byteLength",
                                  "byteOffset",
                                  "length"
                                ],
                                "additionalProperties": {
                                  "type": "number"
                                }
                              }
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ],
                              "additionalProperties": {
                                "type": "number"
                              }
                            }
                          ],
                          "description": "An array of strings or a Buffer naming possible ALPN protocols. (Protocols should be ordered by their priority.)"
                        },
                        "SNICallback": {
                          "description": "SNICallback(servername, cb) <Function> A function that will be called if the client supports SNI TLS extension. Two arguments will be passed when called: servername and cb. SNICallback should invoke cb(null, ctx), where ctx is a SecureContext instance. (tls.createSecureContext(...) can be used to get a proper SecureContext.) If SNICallback wasn't provided the default callback with high-level API will be used (see below)."
                        },
                        "rejectUnauthorized": {
                          "type": "boolean",
                          "description": "If true the server will reject any connection which is not authorized with the list of supplied CAs. This option only has an effect if requestCert is true.",
                          "default": true
                        },
                        "ca": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option."
                        },
                        "cert": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private key, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see ca). When providing multiple cert chains, they do not have to be in the same order as their private keys in key. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail."
                        },
                        "sigalgs": {
                          "type": "string",
                          "description": "Colon-separated list of supported signature algorithms. The list can contain digest algorithms (SHA256, MD5 etc.), public key algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g 'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512)."
                        },
                        "ciphers": {
                          "type": "string",
                          "description": "Cipher suite specification, replacing the default. For more information, see modifying the default cipher suite. Permitted ciphers can be obtained via tls.getCiphers(). Cipher names must be uppercased in order for OpenSSL to accept them."
                        },
                        "clientCertEngine": {
                          "type": "string",
                          "description": "Name of an OpenSSL engine which can provide the client certificate."
                        },
                        "crl": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                        },
                        "dhparam": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            }
                          ],
                          "description": "Diffie Hellman parameters, required for Perfect Forward Secrecy. Use openssl dhparam to create the parameters. The key length must be greater than or equal to 1024 bits or else an error will be thrown. Although 1024 bits is permissible, use 2048 bits or larger for stronger security. If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available."
                        },
                        "ecdhCurve": {
                          "type": "string",
                          "description": "A string describing a named curve or a colon separated list of curve NIDs or names, for example P-521:P-384:P-256, to use for ECDH key agreement. Set to auto to select the curve automatically. Use crypto.getCurves() to obtain a list of available curve names. On recent releases, openssl ecparam -list_curves will also display the name and description of each available elliptic curve. Default: tls.DEFAULT_ECDH_CURVE."
                        },
                        "honorCipherOrder": {
                          "type": "boolean",
                          "description": "Attempt to use the server's cipher suite preferences instead of the client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be set in secureOptions"
                        },
                        "key": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "pem": {
                                        "anyOf": [
                                          {
                                            "type": "string"
                                          },
                                          {
                                            "type": "object",
                                            "properties": {
                                              "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                              },
                                              "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                              },
                                              "byteLength": {
                                                "type": "number"
                                              },
                                              "byteOffset": {
                                                "type": "number"
                                              },
                                              "length": {
                                                "type": "number"
                                              }
                                            },
                                            "required": [
                                              "BYTES_PER_ELEMENT",
                                              "buffer",
                                              "byteLength",
                                              "byteOffset",
                                              "length"
                                            ]
                                          }
                                        ],
                                        "description": "Private keys in PEM format."
                                      },
                                      "passphrase": {
                                        "type": "string",
                                        "description": "Optional passphrase."
                                      }
                                    },
                                    "required": [
                                      "pem"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with options.passphrase. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form {pem: <string|buffer>[, passphrase: <string>]}. The object form can only occur in an array. object.passphrase is optional. Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase if it is not."
                        },
                        "privateKeyEngine": {
                          "type": "string",
                          "description": "Name of an OpenSSL engine to get private key from. Should be used together with privateKeyIdentifier."
                        },
                        "privateKeyIdentifier": {
                          "type": "string",
                          "description": "Identifier of a private key managed by an OpenSSL engine. Should be used together with privateKeyEngine. Should not be set together with key, because both options define a private key in different ways."
                        },
                        "maxVersion": {
                          "$ref": "#/definitions/SecureVersion",
                          "description": "Optionally set the maximum TLS version to allow. One of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the `secureProtocol` option, use one or the other.\n**Default:** `'TLSv1.3'`, unless changed using CLI options. Using `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used."
                        },
                        "minVersion": {
                          "$ref": "#/definitions/SecureVersion",
                          "description": "Optionally set the minimum TLS version to allow. One of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the `secureProtocol` option, use one or the other.  It is not recommended to use less than TLSv1.2, but it may be required for interoperability.\n**Default:** `'TLSv1.2'`, unless changed using CLI options. Using `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used."
                        },
                        "passphrase": {
                          "type": "string",
                          "description": "Shared passphrase used for a single private key and/or a PFX."
                        },
                        "pfx": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "BYTES_PER_ELEMENT": {
                                  "type": "number"
                                },
                                "buffer": {
                                  "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                  "type": "number"
                                },
                                "byteOffset": {
                                  "type": "number"
                                },
                                "length": {
                                  "type": "number"
                                }
                              },
                              "required": [
                                "BYTES_PER_ELEMENT",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                              ]
                            },
                            {
                              "type": "array",
                              "items": {
                                "anyOf": [
                                  {
                                    "type": "string"
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                      },
                                      "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                      },
                                      "byteLength": {
                                        "type": "number"
                                      },
                                      "byteOffset": {
                                        "type": "number"
                                      },
                                      "length": {
                                        "type": "number"
                                      }
                                    },
                                    "required": [
                                      "BYTES_PER_ELEMENT",
                                      "buffer",
                                      "byteLength",
                                      "byteOffset",
                                      "length"
                                    ]
                                  },
                                  {
                                    "type": "object",
                                    "properties": {
                                      "buf": {
                                        "anyOf": [
                                          {
                                            "type": "string"
                                          },
                                          {
                                            "type": "object",
                                            "properties": {
                                              "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                              },
                                              "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                              },
                                              "byteLength": {
                                                "type": "number"
                                              },
                                              "byteOffset": {
                                                "type": "number"
                                              },
                                              "length": {
                                                "type": "number"
                                              }
                                            },
                                            "required": [
                                              "BYTES_PER_ELEMENT",
                                              "buffer",
                                              "byteLength",
                                              "byteOffset",
                                              "length"
                                            ]
                                          }
                                        ],
                                        "description": "PFX or PKCS12 encoded private key and certificate chain."
                                      },
                                      "passphrase": {
                                        "type": "string",
                                        "description": "Optional passphrase."
                                      }
                                    },
                                    "required": [
                                      "buf"
                                    ]
                                  }
                                ]
                              }
                            }
                          ],
                          "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an alternative to providing key and cert individually. PFX is usually encrypted, if it is, passphrase will be used to decrypt it. Multiple PFX can be provided either as an array of unencrypted PFX buffers, or an array of objects in the form {buf: <string|buffer>[, passphrase: <string>]}. The object form can only occur in an array. object.passphrase is optional. Encrypted PFX will be decrypted with object.passphrase if provided, or options.passphrase if it is not."
                        },
                        "secureOptions": {
                          "type": "number",
                          "description": "Optionally affect the OpenSSL protocol behavior, which is not usually necessary. This should be used carefully if at all! Value is a numeric bitmask of the SSL_OP_* options from OpenSSL Options"
                        },
                        "secureProtocol": {
                          "type": "string",
                          "description": "Legacy mechanism to select the TLS protocol version to use, it does not support independent control of the minimum and maximum version, and does not support limiting the protocol to TLSv1.3. Use minVersion and maxVersion instead. The possible values are listed as SSL_METHODS, use the function names as strings. For example, use 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow any TLS protocol version up to TLSv1.3. It is not recommended to use TLS versions less than 1.2, but it may be required for interoperability. Default: none, see minVersion."
                        },
                        "sessionIdContext": {
                          "type": "string",
                          "description": "Opaque identifier used by servers to ensure session state is not shared between applications. Unused by clients."
                        },
                        "ticketKeys": {
                          "type": "object",
                          "properties": {
                            "BYTES_PER_ELEMENT": {
                              "type": "number"
                            },
                            "buffer": {
                              "$ref": "#/definitions/ArrayBufferLike"
                            },
                            "byteLength": {
                              "type": "number"
                            },
                            "byteOffset": {
                              "type": "number"
                            },
                            "length": {
                              "type": "number"
                            }
                          },
                          "required": [
                            "BYTES_PER_ELEMENT",
                            "buffer",
                            "byteLength",
                            "byteOffset",
                            "length"
                          ],
                          "description": "48-bytes of cryptographically strong pseudo-random data. See Session Resumption for more information."
                        },
                        "sessionTimeout": {
                          "type": "number",
                          "description": "The number of seconds after which a TLS session created by the server will no longer be resumable. See Session Resumption for more information. Default: 300."
                        },
                        "host": {
                          "type": "string"
                        },
                        "port": {
                          "type": "number"
                        },
                        "path": {
                          "type": "string"
                        },
                        "socket": {
                          "type": "object",
                          "properties": {
                            "writable": {
                              "type": "boolean",
                              "description": "Is `true` if it is safe to call `writable.write()`, which means the stream has not been destroyed, errored or ended."
                            },
                            "writableEnded": {
                              "type": "boolean",
                              "description": "Is `true` after `writable.end()` has been called. This property does not indicate whether the data has been flushed, for this use `writable.writableFinished` instead."
                            },
                            "writableFinished": {
                              "type": "boolean",
                              "description": "Is set to `true` immediately before the `'finish'` event is emitted."
                            },
                            "writableHighWaterMark": {
                              "type": "number",
                              "description": "Return the value of `highWaterMark` passed when creating this `Writable`."
                            },
                            "writableLength": {
                              "type": "number",
                              "description": "This property contains the number of bytes (or objects) in the queue ready to be written. The value provides introspection data regarding the status of the `highWaterMark`."
                            },
                            "writableObjectMode": {
                              "type": "boolean",
                              "description": "Getter for the property `objectMode` of a given `Writable` stream."
                            },
                            "writableCorked": {
                              "type": "number",
                              "description": "Number of times `writable.uncork()` needs to be called in order to fully uncork the stream."
                            },
                            "destroyed": {
                              "type": "boolean",
                              "description": "Is `true` after `readable.destroy()` has been called."
                            },
                            "closed": {
                              "type": "boolean",
                              "description": "Is true after 'close' has been emitted."
                            },
                            "errored": {
                              "anyOf": [
                                {
                                  "type": "object",
                                  "properties": {
                                    "name": {
                                      "type": "string"
                                    },
                                    "message": {
                                      "type": "string"
                                    },
                                    "stack": {
                                      "type": "string"
                                    }
                                  },
                                  "required": [
                                    "name",
                                    "message"
                                  ]
                                },
                                {
                                  "type": "null"
                                }
                              ],
                              "description": "Returns error if the stream has been destroyed with an error."
                            },
                            "writableNeedDrain": {
                              "type": "boolean",
                              "description": "Is `true` if the stream's buffer has been full and stream will emit 'drain'."
                            },
                            "readable": {
                              "type": "boolean",
                              "description": "Is `true` if it is safe to call `readable.read()`, which means the stream has not been destroyed or emitted `'error'` or `'end'`."
                            },
                            "readableAborted": {
                              "type": "boolean",
                              "description": "Returns whether the stream was destroyed or errored before emitting `'end'`."
                            },
                            "readableDidRead": {
                              "type": "boolean",
                              "description": "Returns whether `'data'` has been emitted."
                            },
                            "readableEncoding": {
                              "anyOf": [
                                {
                                  "$ref": "#/definitions/global.BufferEncoding"
                                },
                                {
                                  "type": "null"
                                }
                              ],
                              "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method."
                            },
                            "readableEnded": {
                              "type": "boolean",
                              "description": "Becomes `true` when `'end'` event is emitted."
                            },
                            "readableFlowing": {
                              "type": [
                                "boolean",
                                "null"
                              ],
                              "description": "This property reflects the current state of a `Readable` stream as described in the `Three states` section."
                            },
                            "readableHighWaterMark": {
                              "type": "number",
                              "description": "Returns the value of `highWaterMark` passed when creating this `Readable`."
                            },
                            "readableLength": {
                              "type": "number",
                              "description": "This property contains the number of bytes (or objects) in the queue ready to be read. The value provides introspection data regarding the status of the `highWaterMark`."
                            },
                            "readableObjectMode": {
                              "type": "boolean",
                              "description": "Getter for the property `objectMode` of a given `Readable` stream."
                            },
                            "allowHalfOpen": {
                              "type": "boolean",
                              "description": "If `false` then the stream will automatically end the writable side when the readable side ends. Set initially by the `allowHalfOpen` constructor option, which defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is emitted."
                            }
                          },
                          "required": [
                            "allowHalfOpen",
                            "closed",
                            "destroyed",
                            "errored",
                            "readable",
                            "readableAborted",
                            "readableDidRead",
                            "readableEncoding",
                            "readableEnded",
                            "readableFlowing",
                            "readableHighWaterMark",
                            "readableLength",
                            "readableObjectMode",
                            "writable",
                            "writableCorked",
                            "writableEnded",
                            "writableFinished",
                            "writableHighWaterMark",
                            "writableLength",
                            "writableNeedDrain",
                            "writableObjectMode"
                          ],
                          "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                        },
                        "checkServerIdentity": {
                          "$comment": "(hostname: string, cert: PeerCertificate) ->  Error | undefined"
                        },
                        "servername": {
                          "type": "string"
                        },
                        "session": {
                          "type": "object",
                          "properties": {
                            "BYTES_PER_ELEMENT": {
                              "type": "number"
                            },
                            "buffer": {
                              "$ref": "#/definitions/ArrayBufferLike"
                            },
                            "byteLength": {
                              "type": "number"
                            },
                            "byteOffset": {
                              "type": "number"
                            },
                            "length": {
                              "type": "number"
                            }
                          },
                          "required": [
                            "BYTES_PER_ELEMENT",
                            "buffer",
                            "byteLength",
                            "byteOffset",
                            "length"
                          ]
                        },
                        "minDHSize": {
                          "type": "number"
                        },
                        "lookup": {
                          "$ref": "#/definitions/LookupFunction"
                        },
                        "timeout": {
                          "type": "number"
                        }
                      }
                    }
                  ]
                },
                "query_timeout": {
                  "type": "number"
                },
                "keepAliveInitialDelayMillis": {
                  "type": "number"
                },
                "idle_in_transaction_session_timeout": {
                  "type": "number"
                },
                "application_name": {
                  "type": "string"
                },
                "connectionTimeoutMillis": {
                  "type": "number"
                },
                "types": {
                  "type": "object",
                  "properties": {
                    "getTypeParser": {}
                  },
                  "required": [
                    "getTypeParser"
                  ]
                },
                "max": {
                  "type": "number"
                },
                "min": {
                  "type": "number"
                },
                "idleTimeoutMillis": {
                  "type": "number"
                },
                "log": {},
                "Promise": {
                  "$ref": "#/definitions/PromiseConstructorLike"
                }
              }
            }
          ],
          "description": "By default use environment variables"
        },
        "autoCreateTable": {
          "type": "boolean",
          "description": "Auto create table if not exists"
        },
        "openapi": {
          "type": "object",
          "additionalProperties": true
        }
      },
      "required": [
        "asyncDelete",
        "database",
        "slowQueryThreshold",
        "table",
        "type"
      ],
      "$schema": "http://json-schema.org/draft-07/schema#",
      "definitions": {
        "StoreExposeParameters": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL endpoint to use to expose REST Resources API",
              "default": "service.getName().toLowerCase()"
            },
            "restrict": {
              "type": "object",
              "properties": {
                "create": {
                  "type": "boolean",
                  "description": "Do not expose the POST"
                },
                "update": {
                  "type": "boolean",
                  "description": "Do not expose the PUT and PATCH"
                },
                "get": {
                  "type": "boolean",
                  "description": "Do not expose the GET"
                },
                "delete": {
                  "type": "boolean",
                  "description": "Do not expose the DELETE"
                },
                "query": {
                  "type": "boolean",
                  "description": "Do not expose the query endpoint"
                }
              },
              "description": "You can restrict any part of the CRUD",
              "default": {}
            },
            "queryMethod": {
              "type": "string",
              "enum": [
                "PUT",
                "GET"
              ],
              "description": "For confidentiality sometimes you might prefer to expose query through PUT To avoid GET logging",
              "default": "GET"
            }
          },
          "deprecated": "Store should not be exposed directly anymore\nYou should use the DomainService instead"
        },
        "global.BufferEncoding": {
          "type": "string",
          "enum": [
            "ascii",
            "utf8",
            "utf-8",
            "utf16le",
            "ucs2",
            "ucs-2",
            "base64",
            "base64url",
            "latin1",
            "binary",
            "hex"
          ]
        },
        "ArrayBufferLike": {
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "byteLength": {
                  "type": "number"
                }
              },
              "required": [
                "byteLength"
              ]
            },
            {}
          ]
        },
        "SecureVersion": {
          "type": "string",
          "enum": [
            "TLSv1.3",
            "TLSv1.2",
            "TLSv1.1",
            "TLSv1"
          ]
        },
        "LookupFunction": {},
        "PromiseConstructorLike": {}
      },
      "title": "PostgresStore"
    }
  }
}