import { SubscriptionMixIn } from "@webda/cloudevents";
import { CloudEvent, EmitterFunction } from "cloudevents";
import { randomUUID } from "crypto";
import { CoreModel } from "./models/coremodel";
import { ModelRef } from "./models/coremodelref";
import { Service } from "./services/service";

/**
 * Contains all registered Event emitter in the application
 */
export const Emitters = new Map<Function, [string, Function[], Function]>();

/**
 * Register the events emitted by the class
 *
 * @param events
 * @param serviceId
 */
export function Emits(events: EventType[], serviceId?: string) {
  return function (constructor: Function, _ctx: any) {
    Emitters.set(constructor, [serviceId || constructor.name, events, constructor]);
  };
}

export class Subscription extends SubscriptionMixIn(Object) {}

export class SharedSubscription<T extends CloudEvent = CloudEvent>
  extends SubscriptionMixIn(CoreModel)
  implements Subscription
{
  protocol: "WEBDA" = "WEBDA";

  /**
   * Callback to call when an event is received
   */
  callback?: (event: T) => void | Promise<void>;

  /**
   * Register the subscription and start listening to the events
   * @param callback
   */
  register(callback: (event: CloudEvent) => void | Promise<void>): this {
    this.sink = "local";

    service.subscribe(this);
    this.callback = callback;
    return this;
  }

  createEmitter(): EmitterFunction {
    if (this.sink === "local") {
      return <EmitterFunction>(this.callback || (async () => {}));
    }
    return super.createEmitter();
  }

  /**
   * Unregister the subscription
   */
  unregister() {
    service.unsubscribe(this);
  }

  /**
   * Load the subscription from the storage
   * @param id
   */
  load(data: Partial<this>): this {
    Object.assign(this, data);
    return this;
  }
}

/**
 * LocalSubscription is a subscription that is only local it won't be sent over the wire
 */
export class LocalSubscription<T extends CloudEvent<any> = CloudEvent<any>> extends Subscription {
  protocol: "WEBDA" = "WEBDA";

  constructor() {
    super();
    this.sink = "local";
  }

  /**
   * Callback to call when an event is received
   */
  callback?: (event: T) => void | Promise<void>;

  /**
   * Register the subscription and start listening to the events
   * @param callback
   */
  register(callback: (event: CloudEvent) => void | Promise<void>): this {
    service.subscribe(this);
    this.callback = callback;
    return this;
  }

  /**
   * Use the callback as the emitter
   * @returns
   */
  createEmitter(): EmitterFunction {
    if (this.sink === "local") {
      return <EmitterFunction>(this.callback || (async () => {}));
    }
    return super.createEmitter();
  }
}

//type EventConstructor<T extends Event> = new (data: T["data"], source: CoreModel | Service) => T;

/**
 * EventType definition
 *
export type EventType<T = any> = Constructor<Event<T>, [Partial<CloudEvent<T>>, any]> & {
  getType: (source: Function) => string;
};
*/
export interface EventType<T = any> {
  new (data: T, source: CoreModel | Service): Event<T>;
  getType: (source: Function) => string;
}

/**
 * Ensure the event is emitted by the declared source
 */
export class Event<T = unknown> extends CloudEvent<T> implements EventType<T> {
  /**
   * Prefix for all events
   */
  static prefix: string = "";
  /**
   * Type of the event
   */
  static type: string = "";
  /**
   *
   * @returns
   */
  static getType(_source: Function) {
    return this.prefix + this.type;
  }
  /**
   *
   * @returns
   */
  static getSubscription(events: any[], source?: Function) {
    return events.map(e => e.getType(source));
  }
  /**
   *
   * @returns
   */
  static canAccess() {
    return false;
  }
  /**
   *
   * @param event to create
   * @param source that is emitting the event
   */
  constructor(event: Partial<CloudEvent<T>>, source: any) {
    super(
      {
        ...event,
        source: event.source || source.constructor.name,
        /**
         * If id is not specified then generate a random UUID
         * The CloudEvent library use uuid library to generate the UUID but this is
         */
        id: event.id || randomUUID(),
        /**
         * A small cheat to allow local event to not be slow down by the ISOString
         * `toJSON` method will convert it to ISOString if the event is sent over the wire
         * Otherwise it will keep the timestamp
         *
         * Our benchmark shows a difference of 2x faster
         * On 1M events it is 490ms vs 227ms
         */
        // @ts-ignore
        time: event.time || Date.now()
      },
      // Validating the event is pretty slow
      false
    );
    if (!(Emitters.get(source.constructor) || ["", []])[1].includes(this.constructor)) {
      throw new Error(`Source ${source.constructor} should declare the events it emits (${this.constructor})`);
    }
  }
  getType: (source: Function) => string;

  /**
   *
   * @param ensureDelivery
   * @returns
   */
  emit(ensureDelivery?: boolean): Promise<this> {
    return service.emitEvent(this, ensureDelivery);
  }

  getEventSourceId() {
    return "";
  }

  static getEventSourceId(): string {
    return "";
  }
}

/**
 * EventService is the base class for all event services
 *
 * @category CoreFeatures
 */
export class EventService extends Service {
  /**
   * Get all subscriptions
   */
  subscriptions: Subscription[] = [];

  /**
   * Subscriptions to other nodes events
   */
  clusterSubscriptions: Subscription[] = [];

  /**
   * Initialize the service
   */
  async init() {
    await super.init();
    // Load all subscriptions
    /*
    for await (const sub of Subscription.iterate("")) {
      this.subscribe(sub);
    }
    */
    return this;
  }

  async consumeClusterEvents() {
    // Consume the pub/sub queue
  }

  /**
   * List all the events
   */
  async listEvents() {
    for (let k of Emitters.keys()) {
      const [serviceId, events, clazz] = Emitters.get(k);
      console.log(
        serviceId,
        // @ts-ignore
        events.map(e => e.getType(clazz))
      );
    }
  }

  /**
   * Add a new subscription
   *
   * @param subscription
   * @returns
   */
  subscribe(subscription: Subscription) {
    this.subscriptions.push(subscription);
    if (["webda://cluster", "webda://cluster-all"].includes(subscription.sink)) {
      this.clusterSubscriptions.push(subscription);
    }
    return this;
  }

  /**
   * Unsubscribe a subscription
   * @param subscription
   */
  unsubscribe(subscription: Subscription) {
    this.subscriptions = this.subscriptions.filter(sub => sub !== subscription);
    if (["webda://cluster", "webda://cluster-all"].includes(subscription.sink)) {
      this.clusterSubscriptions = this.clusterSubscriptions.filter(sub => sub !== subscription);
    }
  }

  /**
   * Emit an event
   * @param event
   */
  async emitEvent<T extends CloudEvent<any>>(event: T, ensureDelivery?: boolean): Promise<T> {
    let delivery = Promise.all(this.subscriptions.map(sub => sub.emit(event)));
    if (ensureDelivery) {
      await delivery;
    }
    return event;
  }

  /**
   * Process for subscriptions
   * @param subscriptionNames
   */
  async worker(subscriptionNames: string) {
    subscriptionNames.split(",").forEach(subscriptionName => {
      if (subscriptionName.startsWith("regex:")) {
        // Work with regex
      }
      // Load the subscription
    });
  }
}

export const service = new EventService(null, "EventService", {});

/**
 * SubscriptionEvent is the base class for all events
 *
 * @category CoreFeatures
 */
// export class SubscriptionEvent extends WebdaEvent {
//   constructor(event: Partial<CloudEvent>, source: any, scope: WebdaScope) {
//     super(event, source, scope);
//   }
// }

// Will define a global pub/sub
// Will define an event to queues
// Will

// io.webda.models.test.create -> app/${uuid}/node/${uuid}/model/${uuid}
// io.webda.models.test.update -> app/${uuid}/node/${uuid}/model/${uuid}
// io.webda.models.test.delete -> app/${uuid}/node/${uuid}/model/${uuid}
// io.webda.models.test.get -> app/${uuid}/node/${uuid}/model/${uuid}

// io.webda.services.test.create -> service/${name}

function ModelEvent(action: string) {
  function getType(source: Function): string {
    return `${Event.prefix}${source.name}.${action}`;
  }

  return class<T = any> extends Event<T> {
    static getType = getType;
    static type = action;
    constructor(event: T, source: CoreModel | ModelRef<any>) {
      super(
        {
          data: event,
          type: getType(source.constructor),
          source: source.getUuid()
        },
        source
      );
    }
  };
}

interface ModelCreateEventData<T extends CoreModel> {
  object: T;
}

export class ModelUpdateEvent extends ModelEvent("update") {}
export class ModelCreateEvent<U extends CoreModel = CoreModel> extends ModelEvent("create")<ModelCreateEventData<U>> {}
export class ModelDeleteEvent extends ModelEvent("delete") {}

export class ModelGetEvent extends ModelEvent("get") {}

export class MyOwnEvent extends Event {
  static type: string = "com.test";
}
//new ModelCreateEvent({}, new CoreModel()).emit();

/**
 * Register the events emitted by the class
 *
 * @event ModelCreateEvent when a model is created
 * @event ModelUpdateEvent when a model is updated
 */
@Emits([ModelCreateEvent, ModelUpdateEvent, ModelDeleteEvent, MyOwnEvent])
class Test extends CoreModel {
  async plop() {
    console.log("EMIT");
    await new ModelCreateEvent(
      {
        object: this
      },
      this
    ).emit(true);
    console.log("EMITTED");
  }
}

(async () => {
  Event.prefix = "io.webda.";
  console.log("Events", Event.getSubscription([ModelCreateEvent, ModelUpdateEvent, ModelDeleteEvent], Test));

  // types: Function | string[]
  // source: Function | string | CoreModel | Service
  // filters: Filter[]
  new LocalSubscription()
    .load({
      types: Event.getSubscription([ModelCreateEvent, ModelUpdateEvent, ModelDeleteEvent], Test)
    })
    .register(evt => {
      console.log("PLOP", evt);
    });

  await new Test().plop();
  service.listEvents();
})();
