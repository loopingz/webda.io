"use strict";(self.webpackChunk_webda_docs=self.webpackChunk_webda_docs||[]).push([[65068],{36156:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>a});var r=n(17624),i=n(4552);const s={},d="Events",o={id:"Concepts/Services/Events",title:"Events",description:"The framework use the EventEmitter for events.",source:"@site/pages/Concepts/Services/Events.md",sourceDirName:"Concepts/Services",slug:"/Concepts/Services/Events",permalink:"/docs/Concepts/Services/Events",draft:!1,unlisted:!1,editUrl:"https://github.com/loopingz/webda.io/tree/docs/pages/Concepts/Services/Events.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"CryptoService",permalink:"/docs/Concepts/Services/CryptoService"},next:{title:"Queues",permalink:"/docs/Concepts/Services/Queues"}},l={},a=[{value:"Webda.Init",id:"webdainit",level:3},{value:"Webda.Init.Services",id:"webdainitservices",level:3},{value:"Webda.Create.Services",id:"webdacreateservices",level:3},{value:"Webda.NewContext",id:"webdanewcontext",level:3},{value:"Webda.Request",id:"webdarequest",level:3},{value:"Store.Save",id:"storesave",level:3},{value:"Store.Saved",id:"storesaved",level:3},{value:"Store.Update",id:"storeupdate",level:3},{value:"Store.Updated",id:"storeupdated",level:3},{value:"Store.PartialUpdate",id:"storepartialupdate",level:3},{value:"Store.PArtialUpdated",id:"storepartialupdated",level:3},{value:"Store.Delete",id:"storedelete",level:3},{value:"Store.Deleted",id:"storedeleted",level:3},{value:"Store.Get",id:"storeget",level:3},{value:"Store.Find",id:"storefind",level:3},{value:"Store.Found",id:"storefound",level:3},{value:"Store.WebCreate",id:"storewebcreate",level:3},{value:"Store.WebUpdate",id:"storewebupdate",level:3},{value:"Store.WebGet",id:"storewebget",level:3},{value:"Store.WebDelete",id:"storewebdelete",level:3},{value:"Store.Action",id:"storeaction",level:3},{value:"Store.Actionned",id:"storeactionned",level:3},{value:"Runtime Events",id:"runtime-events",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",mermaid:"mermaid",p:"p",...(0,i.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"events",children:"Events"}),"\n",(0,r.jsx)(t.p,{children:"The framework use the EventEmitter for events."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"emit()"})," this will not wait for any promise returned by listeners"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"emitSync()"})," this will wait for resolution on all promises returned by listeners"]}),"\n",(0,r.jsxs)(t.p,{children:["We also have a mechanism to listen asynchronously to events. They will then be posted to a Queue for them\nto be consumed through a ",(0,r.jsx)(t.code,{children:"AsyncEvent.worker()"})]}),"\n",(0,r.jsx)(t.mermaid,{value:"sequenceDiagram\n\tparticipant S as Service\n\tparticipant As as AsyncEventService\n\tparticipant Q as Queue\n    participant Aw as AsyncEventService Worker\n    As->>S: Bind event to a sendQueue listener\n\tactivate As\n\tS->>As: Emit event\n    As->>Q: Push the event to the queue\n\tdeactivate As\n\tAw->>Q: Consume queue\n\tAw->>Aw: Call the original listener"}),"\n",(0,r.jsx)(t.h3,{id:"webdainit",children:"Webda.Init"}),"\n",(0,r.jsx)(t.h3,{id:"webdainitservices",children:"Webda.Init.Services"}),"\n",(0,r.jsx)(t.h3,{id:"webdacreateservices",children:"Webda.Create.Services"}),"\n",(0,r.jsx)(t.h3,{id:"webdanewcontext",children:"Webda.NewContext"}),"\n",(0,r.jsx)(t.h3,{id:"webdarequest",children:"Webda.Request"}),"\n",(0,r.jsx)(t.h3,{id:"storesave",children:"Store.Save"}),"\n",(0,r.jsx)(t.h3,{id:"storesaved",children:"Store.Saved"}),"\n",(0,r.jsx)(t.h3,{id:"storeupdate",children:"Store.Update"}),"\n",(0,r.jsx)(t.h3,{id:"storeupdated",children:"Store.Updated"}),"\n",(0,r.jsx)(t.h3,{id:"storepartialupdate",children:"Store.PartialUpdate"}),"\n",(0,r.jsx)(t.h3,{id:"storepartialupdated",children:"Store.PArtialUpdated"}),"\n",(0,r.jsx)(t.h3,{id:"storedelete",children:"Store.Delete"}),"\n",(0,r.jsx)(t.h3,{id:"storedeleted",children:"Store.Deleted"}),"\n",(0,r.jsx)(t.h3,{id:"storeget",children:"Store.Get"}),"\n",(0,r.jsx)(t.h3,{id:"storefind",children:"Store.Find"}),"\n",(0,r.jsx)(t.h3,{id:"storefound",children:"Store.Found"}),"\n",(0,r.jsx)(t.h3,{id:"storewebcreate",children:"Store.WebCreate"}),"\n",(0,r.jsx)(t.h3,{id:"storewebupdate",children:"Store.WebUpdate"}),"\n",(0,r.jsx)(t.h3,{id:"storewebget",children:"Store.WebGet"}),"\n",(0,r.jsx)(t.h3,{id:"storewebdelete",children:"Store.WebDelete"}),"\n",(0,r.jsx)(t.h3,{id:"storeaction",children:"Store.Action"}),"\n",(0,r.jsx)(t.h3,{id:"storeactionned",children:"Store.Actionned"}),"\n",(0,r.jsx)(t.h2,{id:"runtime-events",children:"Runtime Events"}),"\n",(0,r.jsx)(t.p,{children:"To implement some clients listeners we can allow listeners by uuid"}),"\n",(0,r.jsx)(t.p,{children:"addModelListener(model: string, uuid: string) // fullUuid?\nremoveModelListener(model: string, uuid: string) // fullUuid?"}),"\n",(0,r.jsx)(t.p,{children:"Get the current map\nThe Pub/Sub will then send all events for this uuid."})]})}function u(e={}){const{wrapper:t}={...(0,i.M)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},4552:(e,t,n)=>{n.d(t,{I:()=>o,M:()=>d});var r=n(11504);const i={},s=r.createContext(i);function d(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);